{"version":3,"sources":["../src/main/dependencyInjector/defaultDependencyInjector.ts"],"names":[],"mappings":"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","file":"defaultDependencyInjector.js","sourcesContent":["'use strict';\nimport {DependencyInjector, Unit, UnitInfo} from \"./dependencyInjector\";\nimport {LoggerFactory} from \"../loggerFactory\";\nimport {Optional} from \"../optional\";\nimport {ObjectUtils} from \"../objectUtils\";\n\nexport class DefaultDependencyInjector implements DependencyInjector {\n  private translationMap: Map<string,string>;\n  private logger;\n  private units: Map<string, Unit>;\n\n  constructor(private loggerFactory?: LoggerFactory) {\n    this.loggerFactory = loggerFactory || new LoggerFactory();\n    this.logger = loggerFactory.getLogger('dependencyInjector');\n    this.translationMap = new Map();\n    this.units = new Map();\n    this.value('dependencyInjector', this);\n  }\n\n  /**\n   * Defines an already resolved value, that will be used by the dependency management to inject in the\n   * classes that has `name` as constructor dependency.\n   *\n   * @param name {string} Name of the dependency.\n   * @param value {string} Value of the dependency.\n   */\n  public async value(name: string, value: any): Promise<void> {\n    name = this.translateName(name);\n    this.logger.debug(`Registering value ${name}.`);\n    let unit: Unit = this.getOrCreateUnit(name);\n    unit.instanceValue = value;\n    unit.resolved = true;\n    await this.resolveReferences(unit);\n  }\n\n  /**\n   * Defines a dependency class, that will be instantiated and injected into the classes that depends on it.\n   *\n   * @param [name] {string} Name of the dependency. When not specified, the name will be extracted from the\n   * class name.\n   * @param classz {function} Function to be instantiated.\n   */\n  public service(classz: any, name: string = null): Promise<boolean> {\n    let unit: Unit = this.getOrCreateUnit(name, classz);\n    return this.add(unit);\n  }\n\n\n  /**\n   * Defines a function that will be used to build the value for the dependency defined by `classz`.\n   *\n   * @param factoryName {string|function} The name of the dependency that will be resolved by the factory function.\n   * If a function is passed to this parameter, the name of the function will be extracted and used instead.\n   *\n   * @param factoryFn {function} Function that will be called to resolve the value of the dependency.\n   * The function will be called with following parameters:\n   * - classz {function} class to be instantiated.\n   * - dependencyValue {*} dependencies to be injected into the class constructor.\n   *\n   * @param factoryContext {any} Context in which the factory function runs. If string, the value will be resolved from\n   * the injector.\n   */\n  public async factory(factoryName: string|Function, factoryFn: Function, factoryContext?: any): Promise<boolean> {\n    this.assertIsFunction(factoryFn, 'The factory must be a function.');\n\n    let classz: Function = (typeof factoryName === 'string') ? null : <Function>factoryName;\n    let name: string = (typeof factoryName === 'string') ? <string>factoryName : null;\n    let unit = this.getOrCreateUnit(name, classz, factoryFn, factoryContext);\n    this.logger.debug(`Registering factory for ${unit.name}`);\n    // unit.instanceValue = factoryFn();\n    return this.add(unit);\n  }\n\n  public findOne(name: any): Optional<any> {\n    if (typeof name !== 'string') {\n      name = ObjectUtils.extractClassName(name);\n    }\n    name = ObjectUtils.toInstanceName(name);\n    name = this.translateName(name);\n    let unit = this.units.get(name);\n    if (!unit || !unit.resolved) {\n      return Optional.empty();\n    }\n    return Optional.ofNullable(unit.instanceValue);\n  }\n\n  public findAll(): UnitInfo[] {\n    return this.getUnitsWithResolvedStatusAs(true).map((unit: Unit) => ({\n      name: unit.name,\n      value: unit.instanceValue,\n      classz: unit.classz\n    }));\n  }\n\n  public assertAllResolved(): void {\n    let unitNames = this.getUnitsWithResolvedStatusAs(false).map(unit => unit.name);\n    if (unitNames.length) {\n      throw new Error(`Some units could not be resolved: ` +\n        Array.from(this.units)\n          .map(value => value[1])\n          .filter((unit: Unit) => !unit.resolved && this.isUnregisteredUnit(unit))\n          .map((unit: Unit) => `\"${unit.name}\"`)\n          .join(',')\n      );\n    }\n  }\n\n  private add(unit: Unit): Promise<boolean> {\n    if (unit.resolved) {\n      this.logger.debug(`Skipping registration of service ${unit.name}. Service is already resolved.`);\n      return;\n    }\n    return this.resolve(unit);\n  }\n\n  private setReference(dependencyName: string, unit: Unit) {\n    let dependencyUnit: Unit = this.getOrCreateUnit(dependencyName);\n    dependencyUnit.referencedBy.set(unit.name, unit);\n    return dependencyUnit;\n  }\n\n  private async resolve(unit: Unit, resolveQueue: string[] = []): Promise<boolean> {\n    const self = this;\n    if (unit.resolved) {\n      return true;\n    }\n    resolveQueue = [].concat(resolveQueue);\n\n    if (resolveQueue.indexOf(unit.name) >= 0) {\n      throw new Error(`Circular dependency found at ${unit.name}: ${resolveQueue.concat(' > ')}`);\n    }\n    resolveQueue.push(unit.name);\n\n    // Unit without classz are those created temporarily by some unit that depends on it.\n    if (this.isUnregisteredUnit(unit)) {\n      return false;\n    }\n\n    let allDependenciesResolved = true;\n    let dependencies = unit.classArgs\n      .map((arg: string) => {\n        let dependencyUnit = this.setReference(arg, unit);\n        allDependenciesResolved = allDependenciesResolved && dependencyUnit.resolved;\n        return dependencyUnit;\n      });\n\n    if (typeof unit.factoryContext === 'string') {\n      let factoryUnit: Unit = this.setReference(unit.factoryContext, unit);\n      allDependenciesResolved = allDependenciesResolved && factoryUnit.resolved;\n    }\n\n    if (!allDependenciesResolved) {\n      return false;\n    }\n\n    let instantiated: boolean = await this.instantiate(unit, dependencies);\n    if (instantiated) {\n      // Resolve the units that depended on this one\n      this.resolveReferences(unit, resolveQueue);\n    }\n    return true;\n  }\n\n  private async resolveReferences(unit: Unit, resolveQueue: string[] = []): Promise<void> {\n    let references = Array.from(unit.referencedBy)\n      .map(value => value[1])\n      .map((referencer: Unit) => this.resolve(referencer, resolveQueue));\n    await Promise.all(references);\n  }\n\n  private getOrCreateUnit(name: string, classz?: Function, factory?: Function, factoryContext?: any): Unit {\n    let unitName: string = this.getInstanceName(classz, name);\n    let classArgs: string[] = [];\n    if (factory) {\n      classArgs = ObjectUtils.extractArgs(factory);\n    } else if (classz) {\n      classArgs = ObjectUtils.extractArgs(classz);\n    }\n\n    let unit = this.units.get(unitName);\n    if (typeof factoryContext === 'function') {\n      factoryContext = this.getInstanceName(factoryContext);\n    }\n    if (unit) {\n      return this.updateUnitData(unit, factory, factoryContext, classz, classArgs);\n    }\n    unit = new Unit(unitName, classz, classArgs, factory, factoryContext);\n    this.units.set(unitName, unit);\n    return unit;\n  }\n\n  private updateUnitData(unit: Unit, factory: Function, factoryContext: any, classz: Function, classArgs: string[]): Unit {\n    unit.factory = unit.factory || factory;\n    unit.classz = unit.classz || classz;\n    unit.classArgs = unit.classArgs.length ? unit.classArgs : classArgs;\n    unit.factoryContext = factoryContext;\n    return unit;\n  }\n\n  private getInstanceName(classz: any, name?: string): string {\n    if (!name || typeof name !== 'string') {\n      let className = ObjectUtils.extractClassName(classz);\n      if (!className) {\n        return;\n      }\n      name = ObjectUtils.toInstanceName(className);\n    }\n    return this.translateName(ObjectUtils.toInstanceName(name));\n  }\n\n  private getUnitsWithResolvedStatusAs(status: boolean): Unit[] {\n    let result: Unit[] = [];\n    for (let unit of this.units.values()) {\n      if (!!unit.resolved === status) {\n        result.push(unit);\n      }\n    }\n    return result;\n  }\n\n  private translateName(name: string): string {\n    if (this.translationMap.has(name)) {\n      return this.translationMap.get(name);\n    }\n    return name;\n  }\n\n  private defaultFactory(classz, dependencies) {\n    this.logger.debug(\"Registering service: \", this.getFunctionName(classz));\n    return new (Function.prototype.bind.apply(classz, [classz].concat(dependencies)));\n  }\n\n  private isUnregisteredUnit(unit: Unit): boolean {\n    return !unit.classz && !unit.factory && !unit.resolved;\n  }\n\n  private async instantiate(unit: Unit, dependencies: Unit[]): Promise<boolean> {\n    if (this.isUnregisteredUnit(unit)) {\n      return false;\n    }\n    let dependencyValues = dependencies.map(dependency => dependency.instanceValue);\n    if (unit.factory) {\n      let factoryContext = (typeof unit.factoryContext === 'string') ? this.getOrCreateUnit(unit.factoryContext).instanceValue : unit.factoryContext || null;\n      unit.instanceValue = await unit.factory.apply(factoryContext, dependencyValues);\n    } else {\n      unit.instanceValue = this.defaultFactory(unit.classz, dependencyValues);\n    }\n    unit.resolved = true;\n    return true;\n  }\n\n  private assertIsFunction(value: Object, errorMessage: string) {\n    if (typeof value !== 'function') {\n      throw new Error(errorMessage);\n    }\n  }\n\n  private getFunctionName(classz: any) {\n    if (typeof classz !== 'string') {\n      return ObjectUtils.extractClassName(classz);\n    }\n    return classz;\n  }\n}"]}